#ifndef __FRONTEND_HPP__
#define __FRONTEND_HPP__

#include <vector>
#include "slots.hpp"
#include "utility.hpp"

class Slot;
class TargetMachineBase;
class Backend;

/*! \class Instruction

    The Instruction base class is intended to be subclassed by instructions
    that the target processor provides. The execute function, and getSlots are
    the most critical, since they provide the actual implementation of the
    instruction. The other methods allow instructions to be printed and
    parsed.

    The entire instructions classes can be generated by the generate.py.
*/
class Instruction
{
public:
    virtual ~Instruction() {};

    /*! The execution function provides an implementation of the instruction,
        applying to the passed in machine. The slots are used to indicate
        which registers, and constants the instruction should use, etc. The
        function should return the number of slots used by the instruction.

        An example of the and instruction for AVR is given below.

            // Cast the given MachineTarget to the correct type
            AvrMachine *mach = static_cast<AvrMachine*>(_mach);

            // Retrieve register
            uint8_t rA = mach->getRegister(slots[0]);
            uint8_t rB = mach->getRegister(slots[1]);

            // Perform the operation, set flags
            rA = rA & rB;
            setFlagSVNZ(mach, rA, 0);

            // Set registers
            mach->setRegister(slots[0], rA);

            return 2;

        @param _mach    The machine state, which will be modified as per the
                        operation of the instruction.
        @param slots    The first slot to be used by the instruction. Normally
                        the list of slots would have been composed of the
                        result of getSlots, with the appropriate pointer to
                        the list passed in here.
        @return         The number of slots used by the instruction (same as
                        getNumberOfSlots).
    */
    virtual unsigned execute(TargetMachineBase *_mach, Slot **slots) = 0;

    /*! Return a list of slots used by the instruction.

        The function allocates the correct number and type of slots for the
        instruction. These are then owned by the callee, and must be
        deallocated.

        For example, a three operand add instruction would return three slots,
        each derived from RegisterSlot.

        @return  A list of slots which the instruction operates on.

    */
    virtual std::vector<Slot*> getSlots() {return {};};

    /*! Return the number of slots that the instruction operates on.

        @return  The number of slots that the instruction's execute method
                 requires.
    */
    virtual unsigned getNumberOfSlots() {return 0};


    virtual std::string toString() { return ""; };

    /*! Represent the instruction as a string.

        E.g. "add r0, r1, r3", if the slots had the values 0, 1 and 3.

        @param slots   The slots the instruction requires.
        @return        A string with a textual representation of the
                       instruction.
    */
    virtual std::string toString(Slot **slots) { return "";};

    /*! Return a string with the instruction mnemonic.

        E.g. "add"

        @return  The instruction mnemonic.
    */
    virtual std::string getName() { return "";};


    /*! Construct a list of slots based on a string.

        The parse function attempts to use the instruction's format to
        determine whether a string matches the instruction. It also extracts
        values for each of the slots used by the instruction, if there is a
        match.

        For example, with the input "add r1, r3, r2", the instruction will
        attempt to match "add", then read three values into slots: 1, 3, 2. If
        the function could not parse the string, false is returned.

        @param input        The string to parse as an instruction.
        @param slotlist     The list to place the recorded slot values in.
        @return             Whether or not the instruction could be parsed,
                            and the slotlist contents are valid.
    */
    virtual bool parse(std::string input, std::vector<Slot*> &slotlist) { return false;};
};

class TargetMachineBase
{

};

/*! \class TargetMachine

    This class holds the state of the processor - the register values. Each
    register also has a written and read bit associated with it, recording
    whether it has been read or changed. Methods are provided for accessing
    each, as well as comparing the state to other states. The class is
    templated, accepting a type for the registers and a number of registers
    for this state.

    This class is designed to be subclassed and customised for a specific
    processor.
*/
template <typename RegisterType, unsigned NumberOfRegisters>
class TargetMachine : public TargetMachineBase
{
public:
    /*! Construct the target machine

        Set all registers to zero, and mark all registers as not read and not
        written.
    */
    TargetMachine()
    {
        for(unsigned i = 0; i < NumberOfRegisters; ++i)
        {
            registers[i] = 0;
            register_written[i] = false;
            register_read[i] = false;
        }
    }

    /*! Initialise the state of the TargetMachine to random.

        All registers are marked as unread and unwritten, and set to a random
        value.
    */
    void initialiseRandom()
    {
        for(int i = 0; i < NumberOfRegisters; ++i)
        {
            registers[i] = (RegisterType) rand();
            register_written[i] = false;
            register_read[i] = false;
        }
    }

    /*! Get the value of a register, specified by a slot.

        @param reg   A slot whose value is the register index
        @return      The value of the register.
    */
    RegisterType getRegister(Slot *reg)
    {
        register_read[reg->getValue()] = true;
        return registers[reg->getValue()];
    }

    /*! Set the value of a register, specified by a slot.

        @param reg      The register to set.
        @param value    The value to set the register to.
    */
    void setRegister(Slot *reg, RegisterType value)
    {
        register_written[reg->getValue()] = true;
        registers[reg->getValue()] = value;
    }

    /*! Get the value of a register, by register number.

        @param reg      The number of the register.
        @return         The value of the register.
    */
    RegisterType getRegisterValue(unsigned reg)
    {
        register_read[reg] = true;
        return registers[reg];
    }

    /*! Set the value of a register, by register number.

        @param reg      The number of the register.
        @param value    The value to set the register to.
    */
    void setRegisterValue(unsigned reg, RegisterType value)
    {
        register_written[reg] = true;
        registers[reg] = value;
    }

    /*! Perform a simple check to determine whether another TargetMachine is the
        same as this one. This is not commutative, since it only checks the
        registers marked as written in this state.

        For example:
            Current machine state:
                r0 = 10, r1 = 20
            Other machine state:
                r0 = 10, r1 = 20, r2 = 30

            The other state is equivalent, since only r0 and r1 are checked.


            Current machine state:
                r0 = 10, r1 = 20, r2 = 20
            Other machine state:
                r0 = 10, r1 = 20

            The other state is not equivalent, since r0, r1 and r2 are checked.

        @param other    The state to check equivalence to.
        @return         Whether or not the states are equivalent.
    */
    bool equivalentState(TargetMachine &other)
    {
        bool equiv = true;

        for(unsigned i = 0; i < NumberOfRegisters; ++i)
            if(register_written[i] && registers[i] != other.registers[i])
                equiv = false;

        return equiv;
    }

    /*! Check whether the other state is contained within the current state.

        This attempts to find out whether there is a permutation of written
        registers in the current state which corresponds to the other state.
        This means that as long as the other register values are amongst the
        written values in our current state, the result is true. The function
        computes a mapping between the current registers and the other
        registers.

        If a mapping is already specified, then it just checks the state is
        contained, as per that mapping. This allows the mapping to be computed
        at first, and then used in subsequent calls, preserving the register
        mapping.

        For example:
            Current machine state:
                r0 = 10, r1 = 20
            Other machine state:
                r4 = 20

            r4 can be mapped onto r1, therefore the current state contains
            state other.

        The function checks that the current state has atleast as many
        register written as the other state. If the current state has N
        registers written and the other state has M register written, the
        number of combinations is N choose M. Each permutation of these M
        registers is then compared to see if a mapping can be found.

        TODO: next_permutation takes ~50% of this function's runtime, perhaps
        the combinations should be cached and reused.

        @param other    The state to test whether it is a subset of the
                        current state.
        @param mapping  A mapping of this state's registers to the other
                        state's registers.
        @return         Whether the written registers in other can be mapped
                        onto the current state.
    */
    bool containsState(TargetMachine &other,
        std::vector<std::pair<unsigned,unsigned>> *mapping=nullptr)
    {
        RegisterType reg_map[NumberOfRegisters];
        RegisterType reg_map_other[NumberOfRegisters];
        unsigned n_reg=0, n_reg_other=0;
        bool equiv;

        // If a mapping is specified, don't try to find one, just compare
        if(mapping && mapping->size() != 0)
        {
            for(auto &map: *mapping)
            {
                if(registers[map.first] != other.registers[map.second] ||
                    !register_written[map.first] || !other.register_written[map.second])
                {
                    return false;
                }
            }
            return true;
        }

        // Fill in the array with the registers that are written
        for(unsigned i = 0; i < NumberOfRegisters; ++i)
        {
            if(register_written[i])
            {
                reg_map[n_reg++] = i;
            }
            if(other.register_written[i])
            {
                reg_map_other[n_reg_other++] = i;
            }
        }

        // If the other state requires more registers than we have, then the
        // states cannot be equivalent.
        if(n_reg_other > n_reg || n_reg_other == 0)
            return false;

        std::vector<unsigned> rm(reg_map, reg_map+n_reg);
        Combinations<unsigned> comb_iter(rm, n_reg_other);
        std::vector<unsigned> reg_list;

        // Iterate over each combination of n_reg_other registers from our
        // register list.
        do
        {
            comb_iter.getSelection(reg_list);

            // Iterate over each permutation of the chosen combination.
            do
            {
                // Check if all the registers match. If they do, then we have
                // found a mapping. If mapping is not null, record this.
                equiv = true;
                for(unsigned i = 0; i < n_reg_other; ++i)
                {
                    if(registers[reg_map[reg_list[i]]] != other.registers[reg_map_other[i]])
                        equiv = false;
                }
                if(equiv)
                {
                    if(mapping)
                        for(unsigned i = 0; i < n_reg_other; ++i)
                            mapping->push_back(std::make_pair(reg_map[reg_list[i]], reg_map_other[i]));
                    break;
                }
            } while(std::next_permutation(reg_list.begin(), reg_list.end()));
            if(equiv)
                break;
        } while(comb_iter.next());

        return equiv;
    }

protected:
    RegisterType registers[NumberOfRegisters];
    bool register_written[NumberOfRegisters];
    bool register_read[NumberOfRegisters];
};


/*! \class TargetMachineWithFlags

    This class extends the TargetMachine class to handle an arbitrary number
    of processor flags.
*/
template <typename RegisterType, unsigned NumberOfRegisters, unsigned NumberOfFlags>
class TargetMachineWithFlags : public TargetMachine<RegisterType, NumberOfRegisters>
{
public:
    /*! Initialise the the class, setting flags to 0.
    */
    TargetMachineWithFlags() : TargetMachine<RegisterType, NumberOfRegisters>()
    {
        for(unsigned i = 0; i < NumberOfFlags; ++i)
            flags[i] = false;

    }

    /*! Set the value of the flags randomly.

        This overrides the initialiseRandom function of TargetMachine, also
        providing randomised flags.

    */
    void initialiseRandom()
    {
        TargetMachine<RegisterType, NumberOfRegisters>::initialiseRandom();

        for(int i = 0; i < NumberOfFlags; ++i)
        {
            flags[i] = rand() & 1;
        }
    }

    /*! Get the value of a flag

        @param flg  The flag to return the value of.
        @return     The value of the flag.
    */
    bool getFlagValue(unsigned flg)
    {
        return flags[flg];
    }

    /*! Set the value of a flag

        @param flg      The flag to set the value of
        @param value    The value to set to.
    */
    void setFlagValue(unsigned flg, bool value)
    {
        flags[flg] = value;
    }

protected:
    bool flags[NumberOfFlags];
    // TODO possible extension: read and write status for flags
};

#endif
