\documentclass{article}

\usepackage{todonotes}
\usepackage{minted}

\begin{document}

\title{GNU Superoptimizer 2: Design}
\author{James Pallister}

\maketitle

\section{Introduction}

\todo[inline]{brief overview}

\subsection{Version 2}

The original GNU Superoptimizer (GSO) was designed to find short branch-free sequences of instructions by bruteforcing a large number of possible sequences. There were several limitations, which this rewrite attempts to fix:

\begin{itemize}
    \item More flexibility. The original GSO was limited to four input operands and one output operand.
    \item More instruction types. The original GSO supported only integer arithmetic instructions. The second version should support memory and floating point, as well as arithmetic which utilizing more than just the carry flag (only the carry flag was supported previously.)
    % \item More
\end{itemize}

\todo[inline]{mention original GSO here}

\todo[inline]{discuss superoptimization in general, and types of superoptimizers}
\todo[inline]{the need for a toolkit, which allows architectures and different types of superoptimziers to be constucted easily}


\section{Components}

The superoptimizer is designed as a toolkit, so that different parts can be pieced together differently depending on what the superoptimizer needs to do, or how the target architecture is defined.

Superoptimization generally consists of four main stages:

\begin{description}
    \item[Enumerating.] This stage enumerates the instructions, selecting which types of instructions should be enumerated and the sequence length.
    \item[Pruning.] There are a huge number of instruction sequences, and they should be pruned, removing the obviously incorrect sequences. This includes techniques such as register renaming, liveness analysis and dead code elimination.
    \item[Testing.] One of the most expensive parts of the superoptimizer is testing whether the instruction is correct or not. The superoptimizer must simulate or run the instructions. Typically, this is performed on a known test vector, and checked whether the resultant values match the goal function. If they match, the test can be repeated to gain confidence about the validity of the sequence.
    \item[Costing.] Finally, if a valid sequence if found, it must be costed to work out whether it is actually better to use this sequence --- this will depend heavily on the specific metric optimizing for (e.g. time, energy, code size).
\end{description}

The toolkit contains algorithms for each of the stages. Below is a small (incomplete) example demonstrating the creation of a list of instructiosn (\texttt{insns}), which is iterated over (with \texttt{bruteforceIterate}). A register renaming pruning technique is applied (\texttt{canonicalIterator}). A quick test of the instruction sequences on an initial test vector is performed (\texttt{testEquivalence}), and then a larger number of tests is performed if this is found to pass (\texttt{testEquivalenceMultiple}).

\begin{minted}{c++}
    // Set up initial test vectors, mach_initial
    // Set up a goal function, goal
    // Compute the expected state, expected = goal(mach_initial)

    // Bruteforce over all instructions
    do {
        vector<Instruction*> insns;

        // Create instructions
        for(auto &factory: current_factories)
            insns.push_back((*factory)());

        // Get a list of all of the slots in the instruction list
        vector<Slot*> slots;
        for(auto insn: insns)
        {
            auto s1 = insn->getSlots();
            slots.insert(slots.end(), s1.begin(), s1.end());
        }

        // Pruning technique: canonical form
        canonicalIterator c_iter(slots);

        do {
            // Quickly eliminate obviously wrong sequences
            if(testEquivalence(insns, slots, mach_initial, expected))
            {
                // Perform more tests, on different test vectors
                if(testEquivalenceMultiple(insns, slot, goal))
                {
                    cout << "Found a sequence:" << endl;
                    cout << print(insns, slots) << endl;
                }
            }
        } while (c_iter.next());

        // Free the instructions and slots
        for(auto slot: slots)
            delete slot;
        for(auto insn: insns)
            delete insn;
    } while (bruteforceIterate(instruction_factories, current));

\end{minted}

The following sections describe in detail the components available and their intended use.

The frontend is the interface to the processor, and holds all the state that the instructions modify. For example, this will include the registers, flags and memory, and provide an interface to to reading and writing these items.

The frontend is operated on by instructions, which implement the functionality of individual instruction, and specify properties about the instruction. Each instruction accepts a number of \textit{slots}, which represent items to be filled in by the superoptimizer. Typically, these are registers or constants. The slots are subclassed into multiple types, representing the type of value they contain.

\subsection{Frontends}


The frontend holds the processor's state --- generally an interface to the registers and memory the processor can access. The instructions all operate on this state, modifying it as per the instruction semantics. All frontends derive from \texttt{TargetMachineBase}, however, \texttt{TargetMachine<RegisterType, NumberOfRegisters>} is generally a more useful base class. This base class defines a number of functions necessary to the class to be used with other functions available.

Important functions provided by \texttt{TargetMachine<...>}:
\begin{description}
    \item[\texttt{setRegister}, \texttt{getRegister}.] These functions each accept a slot object, read the slots value and set the corresponding register. These functions keep track of whether the register has been written to or read from. These status bits can be used keep track of what registers are used by an instruction sequence.
    \item[\texttt{setRegisterValue}, \texttt{getRegisterValue}.] As above, these functions set a register, however, they set a particular register, which is specified.
    \item[\texttt{containsState}.] This function checks whether the state passed in as the parameter (\texttt{other}) is contained within the current state. This is performed by checking which registers are written in the \texttt{other} state, and finding a combination of registers with identical values that are written in the current state. This particular function is useful when finding if an instruction sequence has computed a particular result, but when there may be other side effects of that sequence which can be ignored.

    For example, the state \texttt{r0 = 1, r2 = 20} is contained in the state \texttt{r1 = 20, r2 = 5, r3 = 1}.

    The function can optionally provide a list of register mappings between the two states. If the current state does contain the other state, this mapping is a list of register pairs, where the first register is the register number in the current state, and the second is the register number in the \texttt{other} state.
\end{description}

\subsection{Instructions}

Each instruction the processor can execute is represented as its own class, and C++'s virtual function dispatch can be used to allow simulation of an arbitrary instruction sequence. The instructions themselves hold no state, and instead purely operate on a \texttt{TargetMachineBase}, and a list of \texttt{Slot}s. The instruction provides several methods to enable the execution of the instruction, as well as helper functions, such as returning the number of slots the instruction requires, and input and output of instructions as strings. The key methods are listed below.

\begin{description}
    \item[\texttt{execute}.] The execute method performs the actual operation of the instructions on the provided machine state, as per the given slot values. This will generally involve reading from registers and writing to other registers.
    \item[\texttt{getSlots}.] This helper allocates and returns the slots used by the instruction. By requiring the instruction to provide the slots it uses, a list of arbitrary slot types can be constructed and operated upon.
    \item[\texttt{parse}.] This function provides a way to read in an instruction stream. The function attempts to match the given string to the instruction, and if successful provides a list of the slot values used by the instruction. Thus a sequence of instructions can be built up by repeatedly attempting to parse the instruction, and if the parse is successful the instruction and slots can be stored.
\end{description}

Since there is a large amount of boilerplate code around the instructions --- one class per instruction --- automatic generation of these classes is provided by a configuration file and a python script. This configuration file lists various details about the processor, and then a list of instructions. Each instruction lists it's slots, with details about their type, and then an implementation section. The implementation section is designed so that the data required is already read, and just the computation can be written. For example, a two-operand add operation for the 8-bit AVR is defined operand as,

\begin{verbatim}
    add:
      operands:
        - modifier: "rw"
          type: "RegisterSlot"
          class: "ALL_REGISTERS"
        - modifier: "r"
          type: "RegisterSlot"
          class: "ALL_REGISTERS"
      implementation: |
        rA = rA + rB;
      print_name: "add"
      format: "add {}, {}"
\end{verbatim}

\noindent
The \texttt{operands} section lists the slots (in this case a read-write register, then a read-only register). The registers which are read are automatically set up, so that their values are available in variables \texttt{rA} and \texttt{rB} respectively. Since the first register is also written, it is saved back into the machine state after the implementation section. The entire implementation section forms the generated \texttt{execute} method,

\begin{minted}{c++}
    unsigned execute(TargetMachineBase *_mach, Slot** slots)
    {
        AvrMachine *mach = static_cast<AvrMachine*>(_mach);
        uint8_t rA = mach->getRegister(slots[0]);
        uint8_t rB = mach->getRegister(slots[1]);

        rA = rA + rB;

        mach->setRegister(slots[0], rA);

        return 2;
    }
\end{minted}

The \texttt{format} section defines the input and output of the instruction. The placeholders, \texttt{\{\}}, consume the slots in the order they were defined in. This is used by the utility functions \texttt{print} and \texttt{parseInstructionList} to allow a list of instruction to be printed or parsed.

\subsection{Slots}

The toolkit provides a base \texttt{Slot} class, as well as two derived classes, \texttt{RegisterSlot} to hold register labels, and \texttt{ConstantSlot} to hold constants used by instructions.

The register slot is most commonly used by instructions, representing which register should be retrieved from the frontend, and holding information about whether the register is read or written, as well as a list of possible registers (i.e. the register class). These properties are exploited by various algorithms to reduce the number of redundant sequences that are tested.

\todo[inline]{concept of slots, different types of slots}
\todo[inline]{different ways of iterating over these slots}

\subsection{Testing}
\todo[inline]{ways of testing if a sequence is correct}

\section{Bruteforce superoptimizer example}

\todo[inline]{Give an example of constructing a superoptimizer}


\appendix
\section{Cost functions}
\todo[inline]{how to deal with different cost functions, and whether the search should end when a solution is found, etc}
\todo[inline]{for space, the searhc should end instantly}

\section{Peephole superoptimization}

\todo[inline]{changes required for peephole superoptimization}
\todo[inline]{harvesting the sequences}
\todo[inline]{changes to the testing routines}

\section{Stochastic superoptimization}
\section{Parallelisation}

\end{document}
